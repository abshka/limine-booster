#!/bin/bash
#
# limine-booster-update
#

# --- Script Configuration ---
set -euo pipefail

# --- Global Constants ---
readonly SCRIPT_NAME="limine-booster"
readonly CONFIG_PATH="/etc/default/limine-booster.conf"
readonly LIMINE_CONFIG_PATH="/boot/limine.conf"
readonly MODULES_PATH="/usr/lib/modules"
readonly MACHINE_ID_FILE="/etc/machine-id"
readonly LOCK_DIR="/run/lock/limine-booster"

# --- Global Variables ---
declare -A PACKAGE_KERNEL_MAP=()
declare -A FILE_CACHE=()
declare -A PACKAGE_OWNERS=()
MACHINE_ID=""
MICROCODE_PATH=""
KERNEL_CMDLINE=""



# --- Logging Functions ---

log_info() { printf ">>> [%s] %s\n" "${SCRIPT_NAME}" "$1"; }
log_warning() { printf ">>> [%s] WARNING: %s\n" "${SCRIPT_NAME}" "$1" >&2; }
log_error() { printf "!!! [%s] ERROR: %s\n" "${SCRIPT_NAME}" "$1" >&2; exit 1; }


# --- Utility Functions ---

# Create secure temporary file
create_secure_temp_file() {
    local prefix="${1:-limine-booster}"
    local temp_file

    # Ensure secure temp directory exists
    local secure_temp_dir
    secure_temp_dir="$(dirname "${LIMINE_CONFIG_PATH}")/.tmp"
    mkdir -p "${secure_temp_dir}" || {
        log_error "Failed to create secure temp directory: ${secure_temp_dir}"
    }
    chmod 700 "${secure_temp_dir}"

    temp_file=$(mktemp --tmpdir="${secure_temp_dir}" \
                       --suffix=".tmp" \
                       "${prefix}-XXXXXX") || {
        log_error "Failed to create secure temporary file"
    }

    # Set secure permissions
    chmod 600 "${temp_file}" || {
        rm -f "${temp_file}"
        log_error "Failed to set secure permissions on temporary file"
    }

    echo "${temp_file}"
}

# Initialize global variables once at startup
init_globals() {
    # Cache machine ID with validation
    if [[ -f "${MACHINE_ID_FILE}" && -r "${MACHINE_ID_FILE}" ]]; then
        MACHINE_ID=$(<"${MACHINE_ID_FILE}")
        # Validate machine ID format
        if [[ ! "${MACHINE_ID}" =~ ^[a-f0-9]{32}$ ]]; then
            log_error "Invalid machine ID format: ${MACHINE_ID}. Try: systemd-machine-id-setup"
        fi
    else
        log_error "Machine ID file not found or not readable: ${MACHINE_ID_FILE}"
    fi

    # Cache microcode path with existence check
    if [[ "${ENABLE_MICROCODE:-yes}" == "yes" ]]; then
        if [[ -f "/boot/intel-ucode.img" ]]; then
            MICROCODE_PATH="/intel-ucode.img"
        elif [[ -f "/boot/amd-ucode.img" ]]; then
            MICROCODE_PATH="/amd-ucode.img"
        fi
    fi

    # Cache kernel command line with size limit
    if [[ -n "${CMDLINE_OVERRIDE:-}" ]]; then
        KERNEL_CMDLINE="${CMDLINE_OVERRIDE}"
    elif [[ -f "/proc/cmdline" && -r "/proc/cmdline" ]]; then
        # Read with size limit to prevent memory issues
        KERNEL_CMDLINE=$(head -c 4096 "/proc/cmdline" | tr -d '\n\0')
    else
        log_error "Cannot determine kernel command line. Please set CMDLINE_OVERRIDE in config."
    fi

    # Validate command line is not empty
    [[ -n "${KERNEL_CMDLINE}" ]] || log_error "Kernel command line is empty"
}


# Parse configuration file with error handling
parse_config() {
    if [[ -f "${CONFIG_PATH}" && -r "${CONFIG_PATH}" ]]; then
        # Source config file safely
        local config_content
        config_content=$(head -c 8192 "${CONFIG_PATH}") || {
            log_warning "Failed to read config file: ${CONFIG_PATH}"
            return 0
        }

        # Validate config content before sourcing
        if echo "${config_content}" | grep -q '^[[:space:]]*[A-Z_][A-Z0-9_]*=' ; then
            source "${CONFIG_PATH}" || {
                log_warning "Failed to source config file: ${CONFIG_PATH}"
            }
        else
            log_warning "Config file contains invalid format: ${CONFIG_PATH}"
        fi
    fi
}

# Batch get package owners for multiple files
get_all_package_owners() {
    local files=("$@")

    # Clear existing cache
    PACKAGE_OWNERS=()

    if (( ${#files[@]} == 0 )); then
        return 0
    fi

    # Single pacman call for all files with error handling
    local pacman_output
    if pacman_output=$(pacman -Qo "${files[@]}" 2>/dev/null); then
        # Parse output efficiently
        while IFS=$'\t' read -r file owner; do
            if [[ -n "${file}" && -n "${owner}" ]]; then
                PACKAGE_OWNERS["${file}"]="${owner}"
                FILE_CACHE["owner_${file}"]="${owner}"
            fi
        done < <(echo "${pacman_output}" | awk '{print $1 "\t" $5}')
    fi
}

# Package owner lookup with caching
get_package_owner() {
    local file_path="$1"
    local cache_key="owner_${file_path}"

    # Check cache first
    if [[ -n "${FILE_CACHE[${cache_key}]:-}" ]]; then
        printf "%s" "${FILE_CACHE[${cache_key}]}"
        return 0
    fi

    # Check batch cache
    if [[ -n "${PACKAGE_OWNERS[${file_path}]:-}" ]]; then
        local owner="${PACKAGE_OWNERS[${file_path}]}"
        FILE_CACHE[${cache_key}]="${owner}"
        printf "%s" "${owner}"
        return 0
    fi

    # Fallback to individual query
    local pkg_name
    local clean_path="${file_path#/}"
    pkg_name=$(pacman -Qo "/${clean_path}" 2>/dev/null | awk '{print $5}')

    if [[ -z "${pkg_name}" ]]; then
        log_error "Could not determine owner of file: ${file_path}"
    fi

    FILE_CACHE[${cache_key}]="${pkg_name}"
    printf "%s" "${pkg_name}"
}

# Build package to kernel version mapping from installed kernels
build_package_kernel_map() {
    log_info "Building kernel package mapping..."

    # Collect all files first
    local all_files=()
    local found_files=()
    local boot_files=()

    # Method 1: Find vmlinuz files in modules
    if [[ -d "${MODULES_PATH}" ]]; then
        mapfile -t found_files < <(find "${MODULES_PATH}" -name "vmlinuz" -type f -print0 2>/dev/null | tr '\0' '\n')
    fi

    # Method 2: Find vmlinuz files in /boot
    mapfile -t boot_files < <(find /boot -maxdepth 1 -name "vmlinuz-*" -type f -print0 2>/dev/null | tr '\0' '\n')

    # Combine all files for batch processing
    all_files=("${found_files[@]}" "${boot_files[@]}")

    if (( ${#all_files[@]} == 0 )); then
        log_info "No kernel files found"
        return 0
    fi

    # Batch get owners for all files
    get_all_package_owners "${all_files[@]}"

    # Process standard module files
    for vmlinuz_path in "${found_files[@]}"; do
        if [[ -n "${PACKAGE_OWNERS[${vmlinuz_path}]:-}" ]]; then
            local pkg_name="${PACKAGE_OWNERS[${vmlinuz_path}]}"
            local kernel_version
            kernel_version=$(basename "$(dirname "${vmlinuz_path}")")

            if [[ -n "${pkg_name}" && -n "${kernel_version}" ]]; then
                PACKAGE_KERNEL_MAP["${pkg_name}"]="${kernel_version}"
            fi
        fi
    done

    # Process boot files (AUR and custom kernels)
    for vmlinuz_path in "${boot_files[@]}"; do
        if [[ -n "${PACKAGE_OWNERS[${vmlinuz_path}]:-}" ]]; then
            local pkg_name="${PACKAGE_OWNERS[${vmlinuz_path}]}"

            # Skip if already processed
            [[ -z "${PACKAGE_KERNEL_MAP[${pkg_name}]:-}" ]] || continue

            # Extract kernel name from /boot/vmlinuz-PACKAGE format
            local kernel_name
            kernel_name=$(basename "${vmlinuz_path}" | sed 's/^vmlinuz-//')

            # Try to find corresponding modules directory
            local kernel_version=""
            local best_match=""
            for dir in "${MODULES_PATH}"/*; do
                if [[ -d "${dir}" ]]; then
                    local dir_name
                    dir_name=$(basename "${dir}")
                    # Exact match gets priority
                    if [[ "${dir_name}" == *"${kernel_name}"* ]]; then
                        if [[ "${dir_name}" == "${kernel_name}"* ]]; then
                            kernel_version="${dir_name}"
                            break
                        elif [[ -z "${best_match}" ]]; then
                            best_match="${dir_name}"
                        fi
                    fi
                fi
            done

            # Use best match if exact not found
            [[ -n "${kernel_version}" ]] || kernel_version="${best_match:-${kernel_name}}"

            if [[ -n "${pkg_name}" && -n "${kernel_version}" ]]; then
                PACKAGE_KERNEL_MAP["${pkg_name}"]="${kernel_version}"
            fi
        fi
    done

    log_info "Found ${#PACKAGE_KERNEL_MAP[@]} kernel packages"
}

# Build Booster initramfs image for specified kernel
build_booster_image() {
    local kernel_ver="$1"
    local output_path="$2"
    local force="${3:-false}"

    # Input validation
    [[ -n "${kernel_ver}" ]] || log_error "Kernel version cannot be empty"
    [[ -n "${output_path}" ]] || log_error "Output path cannot be empty"

    log_info "Building Booster image for kernel ${kernel_ver}..."

    # Skip rebuild if image exists and is recent
    local rebuild_threshold_minutes="${REBUILD_THRESHOLD_MINUTES:-60}"
    if [[ "${force}" != "true" && -f "${output_path}" ]] && \
       [[ $(find "${output_path}" -mmin -${rebuild_threshold_minutes} 2>/dev/null) ]]; then
        log_info "Booster image is recent, skipping rebuild: ${output_path}"
        return 0
    fi

    # Create output directory with proper permissions
    local output_dir
    output_dir=$(dirname "${output_path}")
    if ! install -dm700 "${output_dir}" 2>/dev/null; then
        log_error "Failed to create output directory: ${output_dir}"
    fi

    # Build booster initramfs with timeout and resource limits
    local build_timeout="${BOOSTER_BUILD_TIMEOUT:-120}"
    local temp_output
    temp_output=$(create_secure_temp_file "booster-build")

    if timeout "${build_timeout}" nice -n 10 \
       booster build --force --kernel-version "${kernel_ver}" "${temp_output}"; then
        # Atomic move to final location
        if mv "${temp_output}" "${output_path}"; then
            chmod 600 "${output_path}"
            log_info "Booster image successfully created: ${output_path}"
            return 0
        else
            rm -f "${temp_output}"
            log_error "Failed to move Booster image to final location"
        fi
    else
        rm -f "${temp_output}"
        log_error "Booster build failed or timed out for kernel ${kernel_ver}"
    fi
}

# Check if booster is available with version validation
check_booster_available() {
    if ! command -v booster &>/dev/null; then
        log_error "Booster command not found. Please install the 'booster' package."
    fi
    return 0
}

# Limine entry management for main section only
update_limine_entry() {
    local entry_name="$1"
    local kernel_path="$2"
    local initramfs_path="$3"
    local initramfs_type="$4"

    # Input validation with detailed error messages
    [[ -n "${entry_name}" ]] || log_error "Entry name cannot be empty"
    [[ -n "${kernel_path}" ]] || log_error "Kernel path cannot be empty"
    [[ -n "${initramfs_path}" ]] || log_error "Initramfs path cannot be empty"
    [[ -n "${initramfs_type}" ]] || log_error "Initramfs type cannot be empty"

    # Use flock to prevent concurrent modifications
    local lock_file="${LOCK_DIR}/update-limine.lock"
    mkdir -p "${LOCK_DIR}"

    (
        flock -x 200 || log_error "Failed to acquire lock for limine config update"

        local temp_file
        temp_file=$(create_secure_temp_file "limine-config")

    local main_entry="/+Arch Linux"
    local sub_entry="//${entry_name}"

    # Single-pass AWK processing
    awk -v main_entry="${main_entry}" \
        -v sub_entry="${sub_entry}" \
        -v kernel_path_new="    kernel_path: boot():${kernel_path}" \
        -v initramfs_path_new="    module_path: boot():${initramfs_path}" \
        -v microcode_path_new="    module_path: boot():${MICROCODE_PATH}" \
        -v cmdline_new="    kernel_cmdline: ${KERNEL_CMDLINE}" \
        -v enable_microcode="${ENABLE_MICROCODE:-yes}" \
        -v machine_id="${MACHINE_ID}" \
        '
        BEGIN {
            main_found = 0; in_main = 0; skip_entry = 0; sub_added = 0

            # Validate required variables
            if (!kernel_path_new || kernel_path_new == "    kernel_path: boot():") {
                print "ERROR: kernel_path is empty" > "/dev/stderr"
                exit 1
            }
            if (!initramfs_path_new || initramfs_path_new == "    module_path: boot():") {
                print "ERROR: initramfs_path is empty" > "/dev/stderr"
                exit 1
            }
        }

        # Found main entry
        $0 == main_entry {
            main_found = 1
            in_main = 1
            skip_entry = 0
            print $0

            # Handle machine-id comment
            if ((getline next_line) > 0) {
                if (next_line !~ /comment:.*machine-id/) {
                    print "    comment: machine-id=" machine_id
                }
                print next_line
            }
            next
        }

        # Found our target sub-entry - remove it
        $0 == sub_entry {
            skip_entry = 1
            next
        }

        # Skip content of target entry being replaced
        skip_entry {
            if (/^[[:space:]]*\/\// || /^[[:space:]]*\/[^\/]/ || /^[[:space:]]*$/) {
                skip_entry = 0
                if ($0 != sub_entry && !/^[[:space:]]*$/) {
                    print
                }
            }
            next
        }

        # Inside main entry block
        in_main {
            # End of main block when we hit another main entry
            if (/^[[:space:]]*\/[^\/]/) {
                in_main = 0
                if (!sub_added) {
                    print sub_entry
                    print "    protocol: linux"
                    print "    comment: Auto-generated for " substr(sub_entry, 3) " (" initramfs_type ")"
                    print kernel_path_new
                    if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                        print microcode_path_new
                    }
                    print initramfs_path_new
                    if (cmdline_new != "    kernel_cmdline: ") {
                        print cmdline_new
                    }
                    print ""
                    sub_added = 1
                }
                print
                next
            }
            print
            next
        }

        # Outside main entry
        { print }

        END {
            # Add main entry if never found
            if (!main_found) {
                if (NR > 0) print ""
                print main_entry
                print "    comment: machine-id=" machine_id
                print sub_entry
                print "    protocol: linux"
                print "    comment: Auto-generated for " substr(sub_entry, 3) " (" initramfs_type ")"
                print kernel_path_new
                if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                    print microcode_path_new
                }
                print initramfs_path_new
                if (cmdline_new != "    kernel_cmdline: ") {
                    print cmdline_new
                }
            }
            # Add entry to existing main section if not added
            else if (in_main && !sub_added) {
                print sub_entry
                print "    protocol: linux"
                print "    comment: Auto-generated for " substr(sub_entry, 3) " (" initramfs_type ")"
                print kernel_path_new
                if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                    print microcode_path_new
                }
                print initramfs_path_new
                if (cmdline_new != "    kernel_cmdline: ") {
                    print cmdline_new
                }
            }
        }
    ' initramfs_type="${initramfs_type}" "${LIMINE_CONFIG_PATH}" > "${temp_file}"

    # Validate generated configuration
    if [[ ! -s "${temp_file}" ]]; then
        rm -f "${temp_file}"
        log_error "Generated configuration file is empty"
    fi

    # Additional validation: check for basic structure
    if ! grep -q "^/+Arch Linux" "${temp_file}"; then
        rm -f "${temp_file}"
        log_error "Generated configuration missing main entry"
    fi

    # Atomic replacement with backup
    local backup_file="${LIMINE_CONFIG_PATH}.backup.$(date +%s)"
    if cp "${LIMINE_CONFIG_PATH}" "${backup_file}" 2>/dev/null; then
        if mv "${temp_file}" "${LIMINE_CONFIG_PATH}" 2>/dev/null; then
            log_info "Limine configuration updated successfully"
            # Clean up backups (keep last 5)
            find "$(dirname "${LIMINE_CONFIG_PATH}")" -name "$(basename "${LIMINE_CONFIG_PATH}").backup.*" -type f | \
                sort -nr | tail -n +6 | xargs -r rm -f
        else
            # Restore on failure
            mv "${backup_file}" "${LIMINE_CONFIG_PATH}"
            rm -f "${temp_file}"
            log_error "Failed to update Limine configuration, restored"
        fi
    else
        rm -f "${temp_file}"
        log_error "Failed to create backup of Limine configuration"
    fi

    ) 200>"${lock_file}"

    # Clean up lock file
    rm -f "${lock_file}"
}

# Kernel package processing
process_kernel_package() {
    local pkg_name="$1"

    # Input validation
    [[ -n "${pkg_name}" ]] || log_error "Package name cannot be empty"

    log_info "Processing kernel package: ${pkg_name}"

    # Quick package existence check
    if ! pacman -Q "${pkg_name}" &>/dev/null; then
        log_error "Package ${pkg_name} is not installed"
    fi

    # Get kernel version from pre-built mapping
    local kernel_version="${PACKAGE_KERNEL_MAP[${pkg_name}]:-}"
    if [[ -z "${kernel_version}" ]]; then
        log_info "Could not determine kernel version for ${pkg_name}. Skipping."
        return 0
    fi

    # Setup paths with validation
    local dest_dir_rel="/${MACHINE_ID}/${pkg_name}"
    local dest_dir_abs="/boot${dest_dir_rel}"
    local kernel_source="/usr/lib/modules/${kernel_version}/vmlinuz"
    local kernel_dest="${dest_dir_abs}/vmlinuz-${pkg_name}"

    # Create destination directory with proper permissions
    if ! install -dm700 "${dest_dir_abs}" 2>/dev/null; then
        log_error "Failed to create directory: ${dest_dir_abs}"
    fi

    # Copy kernel image if source exists and destination is older
    if [[ -f "${kernel_source}" ]]; then
        if [[ ! -f "${kernel_dest}" ]] || [[ "${kernel_source}" -nt "${kernel_dest}" ]]; then
            if ! cp "${kernel_source}" "${kernel_dest}" 2>/dev/null; then
                log_error "Failed to copy kernel image from ${kernel_source} to ${kernel_dest}"
            fi
            chmod 600 "${kernel_dest}"
        fi
    else
        log_error "Kernel image not found: ${kernel_source}"
    fi

    # Check if booster is available
    if ! check_booster_available; then
        log_info "Booster not available for ${pkg_name}. Skipping."
        return 0
    fi

    local kernel_image_path="${dest_dir_rel}/vmlinuz-${pkg_name}"
    local booster_dest="${dest_dir_abs}/booster-${pkg_name}.img"
    local initramfs_path="${dest_dir_rel}/booster-${pkg_name}.img"
    local entry_title="${pkg_name} ${kernel_version}"

    # Sequential processing
    log_info "Creating entry for ${pkg_name} with Booster"

    if ! build_booster_image "${kernel_version}" "${booster_dest}"; then
        log_error "Failed to build Booster image for ${pkg_name}"
    fi

    # Update Limine configuration
    if ! update_limine_entry "${entry_title}" "${kernel_image_path}" "${initramfs_path}" "booster"; then
        log_error "Failed to update Limine entry for ${pkg_name}"
    fi

    log_info "Successfully created entry for ${pkg_name} with Booster"
}

# Hook mode processing
process_hook_targets() {
    local targets=("$@")
    local processed_packages=()

    for target in "${targets[@]}"; do
        # Pattern check for kernel files
        if [[ ! "${target}" =~ usr/lib/modules/.*/vmlinuz ]]; then
            continue
        fi

        local pkg_name kernel_ver
        pkg_name=$(get_package_owner "${target}")
        kernel_ver=$(basename "$(dirname "${target}")")

        # Avoid processing same package multiple times
        local already_processed=false
        for processed in "${processed_packages[@]}"; do
            if [[ "${processed}" == "${pkg_name}" ]]; then
                already_processed=true
                break
            fi
        done

        if [[ "${already_processed}" == "true" ]]; then
            continue
        fi

        log_info "Processing package ${pkg_name}, kernel version ${kernel_ver}"

        if process_kernel_package "${pkg_name}"; then
            processed_packages+=("${pkg_name}")
        else
            log_warning "Failed to process kernel package: ${pkg_name}"
        fi
    done
}

# Manual sync mode
process_manual_sync() {
    log_info "Running in manual sync mode. Checking all installed kernels..."

    if [[ ${#PACKAGE_KERNEL_MAP[@]} -eq 0 ]]; then
        log_info "No kernel packages found. Nothing to do."
        return 0
    fi

    # Get unique package names and sort them
    local packages=()
    readarray -t packages < <(printf '%s\n' "${!PACKAGE_KERNEL_MAP[@]}" | sort)

    log_info "Found kernel packages: ${packages[*]}"

    # Sequential processing
    for pkg in "${packages[@]}"; do
        process_kernel_package "${pkg}"
    done

    log_info "All kernels synced successfully."
}

# Kernel package removal
remove_kernel_entry() {
    local pkg_name="$1"

    # Input validation
    [[ -n "${pkg_name}" ]] || log_error "Package name cannot be empty"

    # Use flock to prevent concurrent modifications
    local lock_file="${LOCK_DIR}/remove-${pkg_name}.lock"
    mkdir -p "${LOCK_DIR}"

    (
        flock -x 200 || log_error "Failed to acquire lock for ${pkg_name}"

        local temp_file
        temp_file=$(create_secure_temp_file "limine-remove")

        # Check if entries exist before processing
        local found_entries=0
        if grep -qE "^[[:space:]]*\/\/${pkg_name}( [0-9]| - |$)" "${LIMINE_CONFIG_PATH}" 2>/dev/null; then
            found_entries=1
        fi

        if [[ ${found_entries} -eq 0 ]]; then
            log_info "No entries found for package '${pkg_name}'"
            rm -f "${temp_file}"
            return 0
        fi

        log_info "Removing entries for kernel package: ${pkg_name}"

        # Single-pass removal
        awk -v pkg_name="${pkg_name}" '
            BEGIN {
                skip = 0
                pkg_pattern = "^[[:space:]]*\/\/" pkg_name "($|[[:space:]])"
            }

            # Check if line matches our package pattern
            $0 ~ pkg_pattern {
                skip = 1
                next
            }

            # Stop skipping when we hit another entry or main section
            skip && (/^[[:space:]]*\/\// || /^[[:space:]]*\/[^\/]/) {
                skip = 0
                # Check if this new line is also our target package
                if ($0 ~ pkg_pattern) {
                    skip = 1
                    next
                }
                print
                next
            }

            # Skip content of entries being removed
            skip { next }

            # Keep all other lines
            { print }
        ' "${LIMINE_CONFIG_PATH}" > "${temp_file}"

        # Validate the result
        if [[ ! -s "${temp_file}" ]]; then
            rm -f "${temp_file}"
            log_error "Generated configuration after removal is empty"
        fi

        # Atomic replacement
        if ! mv "${temp_file}" "${LIMINE_CONFIG_PATH}" 2>/dev/null; then
            rm -f "${temp_file}"
            log_error "Failed to update Limine configuration"
        fi

    ) 200>"${lock_file}"

    # Clean up lock file
    rm -f "${lock_file}"

    # Automatically update Snapshots entries after successful removal
    if command -v limine-snapper-sync >/dev/null 2>&1; then
        log_info "Updating Snapshots entries with limine-snapper-sync..."
        if timeout 60 limine-snapper-sync 2>/dev/null; then
            log_info "Snapshots updated successfully"
        else
            log_warning "Failed to update Snapshots entries or operation timed out"
        fi
    else
        log_warning "limine-snapper-sync not found, Snapshots not updated"
    fi

    # Clean up kernel files from /boot directory
    local dest_dir="/boot/${MACHINE_ID}/${pkg_name}"
    if [[ -d "${dest_dir}" ]]; then
        log_info "Cleaning up files: ${dest_dir}"
        if ! rm -rf "${dest_dir}" 2>/dev/null; then
            log_warning "Failed to remove directory: ${dest_dir}"
        fi
    fi

    # Clean up duplicate files in /boot root
    local duplicate_files=(
        "/boot/booster-${pkg_name}.img"
        "/boot/vmlinuz-${pkg_name}"
        "/boot/initramfs-${pkg_name}.img"
        "/boot/initramfs-${pkg_name}-fallback.img"
    )

    for duplicate_file in "${duplicate_files[@]}"; do
        if [[ -f "${duplicate_file}" ]]; then
            log_info "Removing duplicate file: ${duplicate_file}"
            if ! rm -f "${duplicate_file}" 2>/dev/null; then
                log_warning "Failed to remove duplicate file: ${duplicate_file}"
            fi
        fi
    done
}

# Cleanup function
cleanup() {
    local exit_code=$?

    # Clean up any remaining temporary files
    find "$(dirname "${LIMINE_CONFIG_PATH}")/.tmp" -name "limine-booster-*" -type f -mmin +60 -delete 2>/dev/null || true

    # Clean up stale lock files (only if not held by running process)
    if [[ -d "${LOCK_DIR}" ]]; then
        for lock in "${LOCK_DIR}"/*.lock; do
            [[ -f "${lock}" ]] || continue
            # Check if lock is held by running process
            flock -n -x "${lock}" true 2>/dev/null && rm -f "${lock}"
        done
    fi
    # Remove directory if empty
    rmdir "${LOCK_DIR}" 2>/dev/null || true

    exit $exit_code
}

# Set up cleanup trap
trap cleanup EXIT INT TERM

# --- Main Function ---
main() {


    # Require root privileges for all operations
    (( EUID == 0 )) || log_error "This script must be run with root privileges."

    # Load configuration and initialize global variables
    parse_config
    init_globals

    # Check for removal mode first
    if [[ "${1:-}" == "--remove" ]]; then
        if [[ -z "${2:-}" ]]; then
            log_error "Package name is required for --remove option"
        fi
        remove_kernel_entry "$2"
        return 0
    fi

    # Build package mapping
    build_package_kernel_map

    # Determine execution mode: hook vs manual sync
    if [[ $# -gt 0 ]]; then
        # Hook mode via command line arguments
        log_info "Running in hook mode (command line)..."
        process_hook_targets "$@"
    elif [[ -n "${TARGETS:-}" ]]; then
        # Hook mode via environment variable
        log_info "Running in hook mode (environment)..."
        # Convert space-separated string to array
        read -ra targets_array <<< "${TARGETS}"
        process_hook_targets "${targets_array[@]}"
    else
        # Manual sync mode - process all installed kernels
        process_manual_sync
    fi
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
