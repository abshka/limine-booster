#!/bin/bash
#
# limine-booster-update
#

# --- Script Configuration ---
set -euo pipefail

# --- Global Constants ---
readonly SCRIPT_NAME="limine-booster"
readonly CONFIG_PATH="/etc/default/limine-booster.conf"
readonly LIMINE_CONFIG_PATH="/boot/limine.conf"
readonly MODULES_PATH="/usr/lib/modules"
readonly MACHINE_ID_FILE="/etc/machine-id"

# --- Global Variables ---
declare -A PACKAGE_KERNEL_MAP=()
declare -A FILE_CACHE=()
MACHINE_ID=""
MICROCODE_PATH=""
KERNEL_CMDLINE=""

# --- Logging Functions ---
log_info() { printf ">>> [%s] %s\n" "${SCRIPT_NAME}" "$1"; }
log_error() { printf "!!! [%s] ERROR: %s\n" "${SCRIPT_NAME}" "$1" >&2; exit 1; }

# --- Utility Functions ---

# Initialize global variables once
init_globals() {
    # Cache machine ID
    if [[ -f "${MACHINE_ID_FILE}" ]]; then
        MACHINE_ID=$(<"${MACHINE_ID_FILE}")
    else
        log_error "Machine ID file not found: ${MACHINE_ID_FILE}"
    fi

    # Cache microcode path
    if [[ "${ENABLE_MICROCODE:-no}" == "yes" ]]; then
        if [[ -f "/boot/intel-ucode.img" ]]; then
            MICROCODE_PATH="/intel-ucode.img"
        elif [[ -f "/boot/amd-ucode.img" ]]; then
            MICROCODE_PATH="/amd-ucode.img"
        fi
    fi

    # Cache kernel command line
    if [[ -n "${CMDLINE_OVERRIDE:-}" ]]; then
        KERNEL_CMDLINE="${CMDLINE_OVERRIDE}"
    elif [[ -f "/proc/cmdline" ]]; then
        KERNEL_CMDLINE=$(<"/proc/cmdline")
    else
        log_error "Cannot determine kernel command line. Please set CMDLINE_OVERRIDE in config."
    fi
}

# Parse configuration file
parse_config() {
    [[ -f "${CONFIG_PATH}" ]] && source "${CONFIG_PATH}"
}

# Get package owner of a file
get_package_owner() {
    local file_path="$1"
    local cache_key="owner_${file_path}"

    if [[ -n "${FILE_CACHE[${cache_key}]:-}" ]]; then
        printf "%s" "${FILE_CACHE[${cache_key}]}"
        return
    fi

    local pkg_name
    pkg_name=$(pacman -Qo "/${file_path}" 2>/dev/null | awk '{print $5}')
    if [[ -z "${pkg_name}" ]]; then
        log_error "Could not determine owner of file: /${file_path}"
    fi

    FILE_CACHE[${cache_key}]="${pkg_name}"
    printf "%s" "${pkg_name}"
}

# Build package to kernel version mapping
build_package_kernel_map() {
    log_info "Building kernel package mapping..."

    # Use a single find command and process results
    while IFS= read -r -d '' vmlinuz_path; do
        local pkg_name kernel_version
        pkg_name=$(pacman -Qo "${vmlinuz_path}" 2>/dev/null | awk '{print $5}')
        if [[ -n "${pkg_name}" ]]; then
            kernel_version=$(basename "$(dirname "${vmlinuz_path}")")
            PACKAGE_KERNEL_MAP["${pkg_name}"]="${kernel_version}"
        fi
    done < <(find "${MODULES_PATH}" -name "vmlinuz" -type f -print0 2>/dev/null)
}

# Build Booster image
build_booster_image() {
    local kernel_ver="$1"
    local output_path="$2"

    log_info "Building Booster image for kernel ${kernel_ver}..."

    # Check if image already exists and is newer than 1 hour
    if [[ -f "${output_path}" ]] && [[ $(find "${output_path}" -mmin -60 2>/dev/null) ]]; then
        log_info "Booster image is recent, skipping rebuild: ${output_path}"
        return 0
    fi

    # Build booster initramfs
    if ! timeout 60 booster build --force --kernel-version "${kernel_ver}" "${output_path}"; then
        log_error "Booster build failed or timed out for kernel ${kernel_ver}"
    fi

    log_info "Booster image successfully created: ${output_path}"
}

# Build mkinitcpio image
build_mkinitcpio_image() {
    local kernel_ver="$1"
    local output_path="$2"

    log_info "Building mkinitcpio image for kernel ${kernel_ver}..."

    # Check if image already exists and is newer than 1 hour
    if [[ -f "${output_path}" ]] && [[ $(find "${output_path}" -mmin -60 2>/dev/null) ]]; then
        log_info "mkinitcpio image is recent, skipping rebuild: ${output_path}"
        return 0
    fi

    # Build mkinitcpio initramfs
    if ! timeout 120 mkinitcpio -k "${kernel_ver}" -g "${output_path}"; then
        log_error "mkinitcpio build failed or timed out for kernel ${kernel_ver}"
    fi

    log_info "mkinitcpio image successfully created: ${output_path}"
}

# Detect available initramfs types for a kernel
detect_initramfs_types() {
    local pkg_name="$1"
    local kernel_version="$2"
    local dest_dir_abs="$3"
    local types=()

    case "${INITRAMFS_TYPES:-auto}" in
        "booster")
            if command -v booster &>/dev/null; then
                types+=("booster")
            fi
            ;;
        "mkinitcpio")
            # Check if mkinitcpio is available for generation
            if command -v mkinitcpio &>/dev/null; then
                types+=("mkinitcpio")
            fi
            ;;
        "both"|"auto")
            # Check for booster
            if command -v booster &>/dev/null; then
                types+=("booster")
            fi

            # Check if mkinitcpio is available for generation
            if command -v mkinitcpio &>/dev/null; then
                types+=("mkinitcpio")
            fi
            ;;
        *)
            log_error "Unknown INITRAMFS_TYPES value: ${INITRAMFS_TYPES}. Supported: booster, mkinitcpio, both, auto"
            ;;
    esac

    printf '%s\n' "${types[@]}"
}

# Limine entry management
update_limine_entry() {
    local entry_name="$1"
    local kernel_path="$2"
    local initramfs_path="$3"
    local initramfs_type="$4"

    local temp_file
    temp_file=$(mktemp) || log_error "Failed to create temporary file"

    local main_entry="/+Arch Linux"
    local sub_entry="//${entry_name}"

    log_info "Creating/updating limine-snapper-sync compatible entries"
    log_info "Main entry: ${main_entry}"
    log_info "Sub entry: ${sub_entry}"

    # First pass: remove exis    print ""
                sub_added = 1
                snapshots_found = 1
            }ting sub-entry if it exists
    awk -v sub_entry="${sub_entry}" '
        BEGIN { in_target = 0 }

        # Start of our target sub-entry
        $0 == sub_entry { in_target = 1; next }

        # End of target when we hit another entry or main section
        in_target && (/^\/\// || /^\/[^\/]/ || /^[[:space:]]*$/) {
            in_target = 0
            if (!/^[[:space:]]*$/) { print }
            next
        }

        # Skip content inside our target entry
        in_target { next }

        # Print everything else
        { print }
    ' "${LIMINE_CONFIG_PATH}" > "${temp_file}.clean"

    # Second pass: add/update main entry and our sub-entry
    awk -v main_entry="${main_entry}" \
        -v sub_entry="${sub_entry}" \
        -v kernel_path_new="    kernel_path: boot():${kernel_path}" \
        -v initramfs_path_new="    module_path: boot():${initramfs_path}" \
        -v microcode_path_new="    module_path: boot():${MICROCODE_PATH}" \
        -v cmdline_new="    kernel_cmdline: ${KERNEL_CMDLINE}" \
        -v enable_microcode="${ENABLE_MICROCODE:-no}" \
        -v machine_id="${MACHINE_ID}" \
        '
        BEGIN { main_found = 0; in_main = 0; sub_added = 0; snapshots_found = 0 }

        # Found main entry
        $0 == main_entry {
            main_found = 1
            in_main = 1
            print $0
            # Check if we need to add machine-id comment
            getline next_line
            if (next_line !~ /comment:.*machine-id/) {
                print "    comment: machine-id=" machine_id
            }
            print next_line
            next
        }

        # Inside main entry block
        in_main {
            # Check for //Snapshots section - insert our entry before it
            if ($0 == "     //Snapshots" && !sub_added) {
                print sub_entry
                print "    protocol: linux"
                print "    comment: Auto-generated for " entry_name
                print kernel_path_new
                if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                    print microcode_path_new
                }
                print initramfs_path_new
                if (cmdline_new != "    kernel_cmdline: ") {
                    print cmdline_new
                }
                print ""
                sub_added = 1
                snapshots_found = 1
            }

            # Hit another main entry, end our block
            if (/^\/[^\/]/) {
                in_main = 0
                if (!sub_added) {
                    print sub_entry
                    print "    protocol: linux"
                    print "    comment: Auto-generated for " entry_name
                    print kernel_path_new
                    if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                        print microcode_path_new
                    }
                    print initramfs_path_new
                    if (cmdline_new != "    kernel_cmdline: ") {
                        print cmdline_new
                    }
                    print ""
                    sub_added = 1
                }
            }
            print
            next
        }

        # Not in main block yet, check if we should create it
        !main_found && /^\/[^\/]/ {
            # Insert main entry before first OS entry
            print main_entry
            print "    comment: machine-id=" machine_id
            print sub_entry
            print "    protocol: linux"
            print "    comment: Auto-generated for " entry_name
            print kernel_path_new
            if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                print microcode_path_new
            }
            print initramfs_path_new
            if (cmdline_new != "    kernel_cmdline: ") {
                print cmdline_new
            }
            print ""
            main_found = 1
            sub_added = 1
        }

        # Print all other lines
        { print }

        END {
            # If we were still in main block and no snapshots found, add our entry
            if (in_main && !sub_added && !snapshots_found) {
                print sub_entry
                print "    protocol: linux"
                print "    comment: Auto-generated for " entry_name
                print kernel_path_new
                if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                    print microcode_path_new
                }
                print initramfs_path_new
                if (cmdline_new != "    kernel_cmdline: ") {
                    print cmdline_new
                }
            }
            # If no main entry was found, add everything at the end
            else if (!main_found) {
                if (NR > 0) print ""
                print main_entry
                print "    comment: machine-id=" machine_id
                print sub_entry
                print "    protocol: linux"
                print "    comment: Auto-generated for " entry_name
                print kernel_path_new
                if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                    print microcode_path_new
                }
                print initramfs_path_new
                if (cmdline_new != "    kernel_cmdline: ") {
                    print cmdline_new
                }
            }
        }
    ' entry_name="${entry_name}" "${temp_file}.clean" > "${temp_file}"

    # Clean up temporary file
    rm -f "${temp_file}.clean"

    # Atomic replacement
    if mv "${temp_file}" "${LIMINE_CONFIG_PATH}"; then
        log_info "Limine configuration updated successfully"
    else
        rm -f "${temp_file}" 2>/dev/null || true
        log_error "Failed to update Limine configuration"
    fi
}

# Kkernel package processing
process_kernel_package() {
    local pkg_name="$1"

    log_info "Processing kernel package: ${pkg_name}"

    # Quick package existence check
    if ! pacman -Q "${pkg_name}" &>/dev/null; then
        log_error "Package ${pkg_name} is not installed"
    fi

    # Get kernel version from pre-built mapping
    local kernel_version="${PACKAGE_KERNEL_MAP[${pkg_name}]:-}"
    if [[ -z "${kernel_version}" ]]; then
        log_info "Could not determine kernel version for ${pkg_name}. Skipping."
        return 0
    fi

    # Setup paths
    local dest_dir_rel="/${MACHINE_ID}/${pkg_name}"
    local dest_dir_abs="/boot${dest_dir_rel}"
    local kernel_source="/boot/vmlinuz-${pkg_name}"
    local kernel_dest="${dest_dir_abs}/vmlinuz-${pkg_name}"

    # Create destination directory
    mkdir -p "${dest_dir_abs}" || log_error "Failed to create directory: ${dest_dir_abs}"

    # Copy kernel image if source exists and destination is older
    if [[ -f "${kernel_source}" ]]; then
        if [[ ! -f "${kernel_dest}" ]] || [[ "${kernel_source}" -nt "${kernel_dest}" ]]; then
            cp "${kernel_source}" "${kernel_dest}" || \
                log_error "Failed to copy kernel image from ${kernel_source} to ${kernel_dest}"
        fi
    else
        log_error "Kernel image not found: ${kernel_source}"
    fi

    # Detect available initramfs types
    local initramfs_types
    readarray -t initramfs_types < <(detect_initramfs_types "${pkg_name}" "${kernel_version}" "${dest_dir_abs}")

    if [[ ${#initramfs_types[@]} -eq 0 ]]; then
        log_info "No supported initramfs types found for ${pkg_name}. Skipping."
        return 0
    fi

    local kernel_image_path="${dest_dir_rel}/vmlinuz-${pkg_name}"

    # Process each initramfs type
    for initramfs_type in "${initramfs_types[@]}"; do
        log_info "Creating entry for ${pkg_name} with ${initramfs_type}"

        case "${initramfs_type}" in
            "booster")
                local booster_dest="${dest_dir_abs}/booster-${pkg_name}.img"
                build_booster_image "${kernel_version}" "${booster_dest}"
                local initramfs_path="${dest_dir_rel}/booster-${pkg_name}.img"
                if [[ "${APPEND_INITRAMFS_TYPE:-yes}" == "yes" ]]; then
                    local entry_suffix=" (Booster)"
                else
                    local entry_suffix=""
                fi
                ;;
            "mkinitcpio")
                # Generate mkinitcpio initramfs in managed location
                local mkinitcpio_dest="${dest_dir_abs}/initramfs-${pkg_name}.img"
                build_mkinitcpio_image "${kernel_version}" "${mkinitcpio_dest}"
                local initramfs_path="${dest_dir_rel}/initramfs-${pkg_name}.img"

                if [[ "${APPEND_INITRAMFS_TYPE:-yes}" == "yes" ]]; then
                    local entry_suffix=" (mkinitcpio)"
                else
                    local entry_suffix=""
                fi
                ;;
            *)
                log_info "Unknown initramfs type: ${initramfs_type}"
                continue
                ;;
        esac

        # Update Limine configuration
        local entry_title="${pkg_name} ${kernel_version}${entry_suffix}"
        update_limine_entry "${entry_title}" "${kernel_image_path}" "${initramfs_path}" "${initramfs_type}"
    done
}

# Hook mode processing
process_hook_targets() {
    local targets=("$@")

    for target in "${targets[@]}"; do
        log_info "Hook triggered for target: ${target}"

        # Pattern check for kernel files
        if [[ ! "${target}" =~ usr/lib/modules/.*/vmlinuz ]]; then
            log_info "Target ${target} is not a kernel, skipping"
            continue
        fi

        local pkg_name kernel_ver
        pkg_name=$(get_package_owner "${target}")
        kernel_ver=$(basename "$(dirname "${target}")")

        log_info "Hook triggered for package ${pkg_name}, kernel version ${kernel_ver}"
        process_kernel_package "${pkg_name}"
    done
}

# Manual sync mode
process_manual_sync() {
    log_info "Running in manual sync mode. Checking all installed kernels..."

    if [[ ${#PACKAGE_KERNEL_MAP[@]} -eq 0 ]]; then
        log_info "No kernel packages found. Nothing to do."
        return 0
    fi

    # Get unique package names and sort them
    local packages=($(printf '%s\n' "${!PACKAGE_KERNEL_MAP[@]}" | sort))

    log_info "Found kernel packages: ${packages[*]}"

    for pkg in "${packages[@]}"; do
        process_kernel_package "${pkg}"
    done

    log_info "All kernels synced."
}

# Kernel package removal
remove_kernel_entry() {
    local pkg_name="$1"

    log_info "Removing entry for kernel package: ${pkg_name}"

    local entry_name="Arch Linux (${pkg_name})"
    local temp_file
    temp_file=$(mktemp) || log_error "Failed to create temporary file"

    # Check if the entry exists
    if ! grep -qF "/${entry_name}" "${LIMINE_CONFIG_PATH}" 2>/dev/null; then
        log_info "Entry '/${entry_name}' not found. Nothing to remove."
        rm -f "${temp_file}" 2>/dev/null || true
        return 0
    fi

    log_info "Removing entry: /${entry_name}"

    # Remove the entry and its content
    awk -v entry_name="/${entry_name}" '
        BEGIN { in_entry = 0; skip = 0 }
        $0 == entry_name {
            in_entry = 1
            skip = 1
            # Skip the comment line before entry if it exists
            if (prev_line ~ /^# Entry automatically created by/) {
                lines[NR-1] = ""
            }
            next
        }
        in_entry && /^\/[^\/]/ {
            in_entry = 0
            skip = 0
        }
        in_entry && /^[[:space:]]*$/ && seen_content {
            in_entry = 0
            skip = 0
            next
        }
        in_entry && NF > 0 {
            seen_content = 1
            skip = 1
        }
        !skip {
            lines[NR] = $0
        }
        { prev_line = $0 }
        END {
            for (i = 1; i <= NR; i++) {
                if (i in lines && lines[i] != "") {
                    print lines[i]
                }
            }
        }
    ' "${LIMINE_CONFIG_PATH}" > "${temp_file}"

    # Atomic replacement
    if mv "${temp_file}" "${LIMINE_CONFIG_PATH}"; then
        log_info "Entry removed from Limine configuration"

        # Clean up associated files if they exist
        local machine_id="${MACHINE_ID}"
        local kernel_dir="/boot/${machine_id}/${pkg_name}"
        if [[ -d "${kernel_dir}" ]]; then
            log_info "Cleaning up kernel files: ${kernel_dir}"
            rm -rf "${kernel_dir}" 2>/dev/null || true
        fi

        log_info "Successfully removed kernel package: ${pkg_name}"
    else
        rm -f "${temp_file}" 2>/dev/null || true
        log_error "Failed to update Limine configuration"
    fi
}

# --- Main Execution ---
main() {
    # Root privileges check
    (( EUID == 0 )) || log_error "This script must be run with root privileges."

    # Initialize configuration and globals
    parse_config
    init_globals

    # Check for removal mode
    if [[ "${1:-}" == "--remove" ]] && [[ -n "${2:-}" ]]; then
        remove_kernel_entry "$2"
        return 0
    fi

    build_package_kernel_map

    # Determine execution mode and process accordingly
    if [[ $# -gt 0 ]]; then
        # Hook mode via command line arguments
        log_info "Running in hook mode (command line)..."
        process_hook_targets "$@"
    elif [[ -n "${TARGETS:-}" ]]; then
        # Hook mode via environment variable
        log_info "Running in hook mode (environment)..."
        # Convert space-separated string to array
        read -ra targets_array <<< "${TARGETS}"
        process_hook_targets "${targets_array[@]}"
    else
        # Manual sync mode
        process_manual_sync
    fi
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
