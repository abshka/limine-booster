#!/bin/bash
#
# limine-booster-update
#

# --- Script Configuration ---
set -euo pipefail

# --- Global Constants ---
readonly SCRIPT_NAME="limine-booster"
readonly CONFIG_PATH="/etc/default/limine-booster.conf"
readonly LIMINE_CONFIG_PATH="/boot/limine.conf"
readonly MODULES_PATH="/usr/lib/modules"
readonly MACHINE_ID_FILE="/etc/machine-id"

# --- Global Variables ---
declare -A PACKAGE_KERNEL_MAP=()
declare -A FILE_CACHE=()
MACHINE_ID=""
MICROCODE_PATH=""
KERNEL_CMDLINE=""

# --- Logging Functions ---
log_info() { printf ">>> [%s] %s\n" "${SCRIPT_NAME}" "$1"; }
log_warning() { printf ">>> [%s] WARNING: %s\n" "${SCRIPT_NAME}" "$1" >&2; }
log_error() { printf "!!! [%s] ERROR: %s\n" "${SCRIPT_NAME}" "$1" >&2; exit 1; }

# --- Utility Functions ---

# Initialize global variables once at startup
init_globals() {
    # Cache machine ID
    if [[ -f "${MACHINE_ID_FILE}" ]]; then
        MACHINE_ID=$(<"${MACHINE_ID_FILE}")
    else
        log_error "Machine ID file not found: ${MACHINE_ID_FILE}"
    fi

    # Cache microcode path
    if [[ "${ENABLE_MICROCODE:-no}" == "yes" ]]; then
        if [[ -f "/boot/intel-ucode.img" ]]; then
            MICROCODE_PATH="/intel-ucode.img"
        elif [[ -f "/boot/amd-ucode.img" ]]; then
            MICROCODE_PATH="/amd-ucode.img"
        fi
    fi

    # Cache kernel command line
    if [[ -n "${CMDLINE_OVERRIDE:-}" ]]; then
        KERNEL_CMDLINE="${CMDLINE_OVERRIDE}"
    elif [[ -f "/proc/cmdline" ]]; then
        KERNEL_CMDLINE=$(<"/proc/cmdline")
    else
        log_error "Cannot determine kernel command line. Please set CMDLINE_OVERRIDE in config."
    fi
}

# Parse configuration file and set defaults
parse_config() {
    [[ -f "${CONFIG_PATH}" ]] && source "${CONFIG_PATH}"
}

# Get package owner of a file with caching
get_package_owner() {
    local file_path="$1"
    local cache_key="owner_${file_path}"

    if [[ -n "${FILE_CACHE[${cache_key}]:-}" ]]; then
        printf "%s" "${FILE_CACHE[${cache_key}]}"
        return
    fi

    local pkg_name
    # Remove leading slash if present to avoid double slashes
    local clean_path="${file_path#/}"
    pkg_name=$(pacman -Qo "/${clean_path}" 2>/dev/null | awk '{print $5}')
    if [[ -z "${pkg_name}" ]]; then
        log_error "Could not determine owner of file: /${file_path}"
    fi

    FILE_CACHE[${cache_key}]="${pkg_name}"
    printf "%s" "${pkg_name}"
}

# Build package to kernel version mapping from installed kernels
build_package_kernel_map() {
    log_info "Building kernel package mapping..."

    # Method 1: Find vmlinuz files in /usr/lib/modules/*/vmlinuz (standard kernels)
    local found_files=()
    if [[ -d "${MODULES_PATH}" ]]; then
        while IFS= read -r vmlinuz_path; do
            found_files+=("${vmlinuz_path}")
        done < <(find "${MODULES_PATH}" -name "vmlinuz" -type f 2>/dev/null)
    fi

    for vmlinuz_path in "${found_files[@]}"; do
        local pkg_name kernel_version
        if pkg_name=$(pacman -Qo "${vmlinuz_path}" 2>/dev/null | awk '{print $5}') && [[ -n "${pkg_name}" ]]; then
            kernel_version=$(basename "$(dirname "${vmlinuz_path}")")
            PACKAGE_KERNEL_MAP["${pkg_name}"]="${kernel_version}"
        fi
    done

    # Method 2: Find vmlinuz files in /boot/vmlinuz-* (AUR and custom kernels)
    local boot_files=()
    while IFS= read -r vmlinuz_path; do
        boot_files+=("${vmlinuz_path}")
    done < <(find /boot -maxdepth 1 -name "vmlinuz-*" -type f 2>/dev/null)

    for vmlinuz_path in "${boot_files[@]}"; do
        local pkg_name kernel_name
        if pkg_name=$(pacman -Qo "${vmlinuz_path}" 2>/dev/null | awk '{print $5}') && [[ -n "${pkg_name}" ]]; then
            # Skip if already found via standard modules method
            if [[ -n "${PACKAGE_KERNEL_MAP[${pkg_name}]:-}" ]]; then
                continue
            fi

            # Extract kernel name from /boot/vmlinuz-PACKAGE format
            kernel_name=$(basename "${vmlinuz_path}" | sed 's/^vmlinuz-//')

            # Try to find corresponding modules directory
            local kernel_version=""
            for dir in "${MODULES_PATH}"/*; do
                if [[ -d "${dir}" ]]; then
                    local dir_name=$(basename "${dir}")
                    # Match patterns: exact or partial match with kernel name
                    if [[ "${dir_name}" == "${kernel_name}"* ]] || [[ "${dir_name}" =~ ${kernel_name} ]]; then
                        kernel_version="${dir_name}"
                        break
                    fi
                fi
            done

            # Fallback: use kernel name if no modules directory found
            if [[ -z "${kernel_version}" ]]; then
                kernel_version="${kernel_name}"
            fi

            PACKAGE_KERNEL_MAP["${pkg_name}"]="${kernel_version}"
        fi
    done
}

# Build Booster initramfs image for specified kernel
build_booster_image() {
    local kernel_ver="$1"
    local output_path="$2"

    # Input validation
    [[ -n "${kernel_ver}" ]] || log_error "Kernel version cannot be empty"
    [[ -n "${output_path}" ]] || log_error "Output path cannot be empty"

    log_info "Building Booster image for kernel ${kernel_ver}..."

    # Skip rebuild if image exists and is recent (within 1 hour)
    if [[ -f "${output_path}" ]] && [[ $(find "${output_path}" -mmin -60 2>/dev/null) ]]; then
        log_info "Booster image is recent, skipping rebuild: ${output_path}"
        return 0
    fi

    # Build booster initramfs
    if ! timeout 60 booster build --force --kernel-version "${kernel_ver}" "${output_path}"; then
        printf "!!! [%s] ERROR: Booster build failed or timed out for kernel %s\n" "${SCRIPT_NAME}" "${kernel_ver}" >&2
        return 1
    fi

    log_info "Booster image successfully created: ${output_path}"
    return 0
}



# Check if booster is available
check_booster_available() {
    if command -v booster &>/dev/null; then
        return 0
    else
        log_error "Booster command not found. Please install the 'booster' package."
        return 1
    fi
}

# Limine entry management for main section only
update_limine_entry() {
    local entry_name="$1"
    local kernel_path="$2"
    local initramfs_path="$3"
    local initramfs_type="$4"

    # Input validation
    [[ -n "${entry_name}" ]] || log_error "Entry name cannot be empty"
    [[ -n "${kernel_path}" ]] || log_error "Kernel path cannot be empty"
    [[ -n "${initramfs_path}" ]] || log_error "Initramfs path cannot be empty"
    [[ -n "${initramfs_type}" ]] || log_error "Initramfs type cannot be empty"

    local temp_file
    temp_file=$(mktemp) || log_error "Failed to create temporary file"

    local main_entry="/+Arch Linux"
    local sub_entry="//${entry_name}"

    # First pass: remove existing sub-entry if it exists
    awk -v sub_entry="${sub_entry}" '
        BEGIN { in_target = 0 }

        # Start of our target sub-entry
        $0 == sub_entry { in_target = 1; next }

        # End of target when we hit another entry or main section
        in_target && (/^\/\// || /^\/[^\/]/ || /^[[:space:]]*$/) {
            in_target = 0
            if (!/^[[:space:]]*$/) { print }
            next
        }

        # Skip content inside our target entry
        in_target { next }

        # Print everything else
        { print }
    ' "${LIMINE_CONFIG_PATH}" > "${temp_file}.clean"

    # Second pass: add/update main entry and our sub-entry
    awk -v main_entry="${main_entry}" \
        -v sub_entry="${sub_entry}" \
        -v kernel_path_new="    kernel_path: boot():${kernel_path}" \
        -v initramfs_path_new="    module_path: boot():${initramfs_path}" \
        -v microcode_path_new="    module_path: boot():${MICROCODE_PATH}" \
        -v cmdline_new="    kernel_cmdline: ${KERNEL_CMDLINE}" \
        -v enable_microcode="${ENABLE_MICROCODE:-no}" \
        -v machine_id="${MACHINE_ID}" \
        '
        BEGIN {
            main_found = 0; in_main = 0; sub_added = 0
            # Validate required variables
            if (kernel_path_new == "    kernel_path: boot():") {
                print "ERROR: kernel_path is empty" > "/dev/stderr"
                exit 1
            }
            if (initramfs_path_new == "    module_path: boot():") {
                print "ERROR: initramfs_path is empty" > "/dev/stderr"
                exit 1
            }
        }

        # Found main entry
        $0 == main_entry {
            main_found = 1
            in_main = 1
            print $0
            # Check if we need to add machine-id comment
            getline next_line
            if (next_line !~ /comment:.*machine-id/) {
                print "    comment: machine-id=" machine_id
            }
            print next_line
            next
        }

        # Inside main entry block
        in_main {
            # End our block when hitting another section
            if (/^\/[^\/]/ || /^[[:space:]]*\/\/Snapshots/) {
                in_main = 0
                if (!sub_added) {
                    print sub_entry
                    print "    protocol: linux"
                    print "    comment: Auto-generated for " entry_name
                    print kernel_path_new
                    if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                        print microcode_path_new
                    }
                    print initramfs_path_new
                    if (cmdline_new != "    kernel_cmdline: ") {
                        print cmdline_new
                    }
                    print ""
                    sub_added = 1
                }
                print
                next
            }

            # Print lines inside main entry
            print
            next
        }

        # Outside main entry or no main entry found yet
        !main_found {
            print
            next
        }

        # Print everything else
        { print }

        END {
            # If we were still in main block and entry not added, add it at the end
            if (in_main && !sub_added) {
                print sub_entry
                print "    protocol: linux"
                print "    comment: Auto-generated for " entry_name
                print kernel_path_new
                if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                    print microcode_path_new
                }
                print initramfs_path_new
                if (cmdline_new != "    kernel_cmdline: ") {
                    print cmdline_new
                }
            }
            # Add main entry if it was never found
            else if (!main_found) {
                if (NR > 0) print ""
                print main_entry
                print "    comment: machine-id=" machine_id
                print sub_entry
                print "    protocol: linux"
                print "    comment: Auto-generated for " entry_name
                print kernel_path_new
                if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
                    print microcode_path_new
                }
                print initramfs_path_new
                if (cmdline_new != "    kernel_cmdline: ") {
                    print cmdline_new
                }
            }
        }
    ' entry_name="${entry_name}" "${temp_file}.clean" > "${temp_file}"

    # Clean up temporary file
    rm -f "${temp_file}.clean" 2>/dev/null || true

    # Validate generated configuration before replacement
    if [[ ! -s "${temp_file}" ]]; then
        rm -f "${temp_file}" 2>/dev/null || true
        log_error "Generated configuration file is empty"
    fi

    # Atomic replacement
    if mv "${temp_file}" "${LIMINE_CONFIG_PATH}" 2>/dev/null; then
        log_info "Limine configuration updated successfully"
    else
        rm -f "${temp_file}" 2>/dev/null || true
        log_error "Failed to update Limine configuration"
    fi
}

# Kernel package processing
process_kernel_package() {
    local pkg_name="$1"

    # Input validation
    [[ -n "${pkg_name}" ]] || log_error "Package name cannot be empty"

    log_info "Processing kernel package: ${pkg_name}"

    # Quick package existence check
    if ! pacman -Q "${pkg_name}" &>/dev/null; then
        log_error "Package ${pkg_name} is not installed"
    fi

    # Get kernel version from pre-built mapping
    local kernel_version="${PACKAGE_KERNEL_MAP[${pkg_name}]:-}"
    if [[ -z "${kernel_version}" ]]; then
        log_info "Could not determine kernel version for ${pkg_name}. Skipping."
        return 0
    fi

    # Setup paths
    local dest_dir_rel="/${MACHINE_ID}/${pkg_name}"
    local dest_dir_abs="/boot${dest_dir_rel}"
    local kernel_source="/boot/vmlinuz-${pkg_name}"
    local kernel_dest="${dest_dir_abs}/vmlinuz-${pkg_name}"

    # Create destination directory
    mkdir -p "${dest_dir_abs}" || log_error "Failed to create directory: ${dest_dir_abs}"

    # Copy kernel image if source exists and destination is older
    if [[ -f "${kernel_source}" ]]; then
        if [[ ! -f "${kernel_dest}" ]] || [[ "${kernel_source}" -nt "${kernel_dest}" ]]; then
            cp "${kernel_source}" "${kernel_dest}" || \
                log_error "Failed to copy kernel image from ${kernel_source} to ${kernel_dest}"
        fi
    else
        log_error "Kernel image not found: ${kernel_source}"
    fi

    # Check if booster is available
    if ! check_booster_available; then
        log_info "Booster not available for ${pkg_name}. Skipping."
        return 0
    fi

    local kernel_image_path="${dest_dir_rel}/vmlinuz-${pkg_name}"

    # Create booster initramfs
    log_info "Creating entry for ${pkg_name} with Booster"

    local booster_dest="${dest_dir_abs}/booster-${pkg_name}.img"
    if ! build_booster_image "${kernel_version}" "${booster_dest}"; then
        log_error "Failed to build Booster image for ${pkg_name}"
        return 1
    fi

    local initramfs_path="${dest_dir_rel}/booster-${pkg_name}.img"
    local entry_title="${pkg_name} ${kernel_version}"

    # Update Limine configuration
    if ! update_limine_entry "${entry_title}" "${kernel_image_path}" "${initramfs_path}" "booster"; then
        log_error "Failed to update Limine entry for ${pkg_name}"
        return 1
    fi

    log_info "Successfully created entry for ${pkg_name} with Booster"
}

# Hook mode processing
process_hook_targets() {
    local targets=("$@")

    for target in "${targets[@]}"; do
        log_info "Hook triggered for target: ${target}"

        # Pattern check for kernel files
        if [[ ! "${target}" =~ usr/lib/modules/.*/vmlinuz ]]; then
            log_info "Target ${target} is not a kernel, skipping"
            continue
        fi

        local pkg_name kernel_ver
        pkg_name=$(get_package_owner "${target}")
        kernel_ver=$(basename "$(dirname "${target}")")

        log_info "Hook triggered for package ${pkg_name}, kernel version ${kernel_ver}"
        process_kernel_package "${pkg_name}"
    done
}

# Manual sync mode
process_manual_sync() {
    log_info "Running in manual sync mode. Checking all installed kernels..."

    if [[ ${#PACKAGE_KERNEL_MAP[@]} -eq 0 ]]; then
        log_info "No kernel packages found. Nothing to do."
        return 0
    fi

    # Get unique package names and sort them
    local packages=($(printf '%s\n' "${!PACKAGE_KERNEL_MAP[@]}" | sort))

    log_info "Found kernel packages: ${packages[*]}"

    for pkg in "${packages[@]}"; do
        process_kernel_package "${pkg}"
    done

    log_info "All kernels synced."
}

# Kernel package removal
remove_kernel_entry() {
    local pkg_name="$1"

    # Input validation
    [[ -n "${pkg_name}" ]] || log_error "Package name cannot be empty"

    log_info "Removing entries for kernel package: ${pkg_name}"

    local temp_file
    temp_file=$(mktemp) || log_error "Failed to create temporary file"

    # Look for entries with package name followed by space, version, dash, or end of line
    local found_entries=0
    if grep -qE "^[[:space:]]*//${pkg_name}( [0-9]| - |$)" "${LIMINE_CONFIG_PATH}" 2>/dev/null; then
        found_entries=1
    fi

    if [[ ${found_entries} -eq 0 ]]; then
        log_info "No entries found for package '${pkg_name}'. Nothing to remove."
        rm -f "${temp_file}" 2>/dev/null || true
        return 0
    fi

    log_info "Removing all entries for package: ${pkg_name}"

    # Remove entries from main /+Arch Linux section only
    # Snapshots are automatically updated by limine-snapper-sync after removal
    awk -v pkg_name="${pkg_name}" '
        BEGIN {
            skip = 0
        }

        # Start skipping when we find a matching entry
        # Match exact package name followed by space, end of line, or specific delimiters
        /^[[:space:]]*\/\/[a-zA-Z0-9_-]+($|[[:space:]])/ {
            # Extract package name from the line
            line = $0
            gsub(/^[[:space:]]*\/\//, "", line)

            # Find the package name - everything before first space or end of string
            split(line, parts, /[[:space:]]/)
            entry_pkg = parts[1]

            if (entry_pkg == pkg_name) {
                skip = 1
                next
            }
        }

        # Stop skipping when we hit another entry or main section
        skip && (/^[[:space:]]*\/\// || /^[[:space:]]*\/[^\/]/) {
            skip = 0
            # Check if this new line is also our target package
            if (/^[[:space:]]*\/\/[a-zA-Z0-9_-]+/) {
                line = $0
                gsub(/^[[:space:]]*\/\//, "", line)
                split(line, parts, /[[:space:]]/)
                entry_pkg = parts[1]

                if (entry_pkg == pkg_name) {
                    skip = 1
                    next
                }
            }
            print
            next
        }

        # Skip content of entries being removed
        skip {
            next
        }

        # Keep all other lines
        {
            print
        }
    ' "${LIMINE_CONFIG_PATH}" > "${temp_file}"

    # Atomic replacement with proper error handling
    if mv "${temp_file}" "${LIMINE_CONFIG_PATH}" 2>/dev/null; then
        log_info "Successfully removed entries for kernel package: ${pkg_name}"

        # Automatically update Snapshots entries after successful removal
        if command -v limine-snapper-sync >/dev/null 2>&1; then
            log_info "Updating Snapshots entries with limine-snapper-sync..."
            if limine-snapper-sync 2>/dev/null; then
                log_info "Snapshots updated successfully"
            else
                log_warning "Failed to update Snapshots entries"
            fi
        else
            log_warning "limine-snapper-sync not found, Snapshots not updated"
        fi
    else
        rm -f "${temp_file}" 2>/dev/null || true
        log_error "Failed to update Limine configuration"
    fi

    # Clean up kernel files from /boot directory
    local dest_dir="/boot/${MACHINE_ID}/${pkg_name}"
    if [[ -d "${dest_dir}" ]]; then
        log_info "Cleaning up files: ${dest_dir}"
        if ! rm -rf "${dest_dir}" 2>/dev/null; then
            log_warning "Failed to remove directory: ${dest_dir}"
        fi
    fi
}

# --- Main Function ---
main() {
    # Require root privileges for all operations
    (( EUID == 0 )) || log_error "This script must be run with root privileges."

    # Load configuration and initialize global variables
    parse_config
    init_globals

    # Check for removal mode first
    if [[ "${1:-}" == "--remove" ]]; then
        if [[ -z "${2:-}" ]]; then
            log_error "Package name is required for --remove option"
        fi
        remove_kernel_entry "$2"
        return 0
    fi

    build_package_kernel_map

    # Determine execution mode: hook vs manual sync
    if [[ $# -gt 0 ]]; then
        # Hook mode via command line arguments
        log_info "Running in hook mode (command line)..."
        process_hook_targets "$@"
    elif [[ -n "${TARGETS:-}" ]]; then
        # Hook mode via environment variable
        log_info "Running in hook mode (environment)..."
        # Convert space-separated string to array
        read -ra targets_array <<< "${TARGETS}"
        process_hook_targets "${targets_array[@]}"
    else
        # Manual sync mode - process all installed kernels
        process_manual_sync
    fi
}

# Execute main function if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
