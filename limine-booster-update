#!/bin/bash
#
# limine-booster-update
#
# This script is designed to be run by a pacman hook. It automatically
# generates a Booster image for a specified kernel package and updates a
# corresponding entry in the Limine bootloader configuration.
#
# It reads its configuration from /etc/default/limine-booster.conf.
#

# --- Script Configuration ---
set -euo pipefail

# --- Global Constants ---
readonly SCRIPT_NAME="limine-booster-manager"
readonly CONFIG_PATH="/etc/default/limine-booster.conf"
readonly LIMINE_CONFIG_PATH="/boot/limine.conf"

# --- Logging Functions ---
log_info() {
    printf ">>> [%s] %s\n" "${SCRIPT_NAME}" "$1"
}

log_error() {
    printf "!!! [%s] ERROR: %s\n" "${SCRIPT_NAME}" "$1" >&2
    exit 1
}

# --- Core Functions ---

parse_config() {
    if [[ ! -f "${CONFIG_PATH}" ]]; then
        log_error "Configuration file not found: ${CONFIG_PATH}"
    fi
    # shellcheck source=/dev/null
    source "${CONFIG_PATH}"
}

get_kernel_version() {
    local pkg_name="$1"
    local kernel_ver
    kernel_ver=$(pacman -Ql "${pkg_name}" | grep -oP '/usr/lib/modules/\K[^/]+' | uniq)
    if [[ -z "${kernel_ver}" ]]; then
        log_error "Could not determine kernel version for package: ${pkg_name}"
    fi
    printf "%s" "${kernel_ver}"
}

get_machine_id() {
    if [[ ! -f "/etc/machine-id" ]]; then
        log_error "Could not read /etc/machine-id. Please ensure the file exists."
    fi
    cat "/etc/machine-id"
}

get_microcode_path() {
    if [[ -f "/boot/intel-ucode.img" ]]; then
        printf "/intel-ucode.img"
    elif [[ -f "/boot/amd-ucode.img" ]]; then
        printf "/amd-ucode.img"
    else
        printf ""
    fi
}

build_booster_image() {
    local kernel_ver="$1"
    local output_path="$2"
    log_info "Building Booster image for kernel ${kernel_ver}..."
    if ! booster build --force --kernel-version "${kernel_ver}" "${output_path}"; then
        log_error "Booster build failed."
    fi
    log_info "Booster image successfully created: ${output_path}"
}

# --- ИСПРАВЛЕННАЯ ФУНКЦИЯ ЗДЕСЬ ---
# Updates the Limine configuration file using a robust awk script.
# This approach preserves all unknown lines (like 'comment' and 'protocol')
# while replacing only the lines it's meant to manage.
update_limine_config() {
    local entry_name="$1"
    local kernel_path="$2"
    local microcode_path="$3"
    local booster_path="$4"
    local cmdline="$5"

    # Ensure the target entry exists before proceeding.
    if ! grep -qF "/${entry_name}" "${LIMINE_CONFIG_PATH}"; then
        log_error "Entry '/${entry_name}' not found in ${LIMINE_CONFIG_PATH}. Please create it manually."
    fi

    log_info "Updating ${LIMINE_CONFIG_PATH}..."

    # Use awk for safe, in-place editing.
    # It finds the target block, prints existing lines like 'comment' and 'protocol',
    # skips old path/cmdline entries, and injects the new ones after the header.
    awk -i inplace \
        -v entry_name="/${entry_name}" \
        -v kernel_path_new="    kernel_path: boot():${kernel_path}" \
        -v booster_path_new="    module_path: boot():${booster_path}" \
        -v microcode_path_new="    module_path: boot():${microcode_path}" \
        -v cmdline_new="    kernel_cmdline: ${cmdline}" \
        -v enable_microcode="${ENABLE_MICROCODE:-no}" \
    '
    # At the start of any line, check if we are leaving a block.
    # A block is defined by a line starting with a forward slash.
    /^\// { in_block = 0 }
    # Check if we are entering OUR target block.
    $0 == entry_name { in_block = 1 }

    # Rule 1: If we are inside the target block and the line is one
    # of the ones we manage, skip it. We will add the new versions later.
    in_block && /^[[:space:]]*(kernel_path:|module_path:|kernel_cmdline:)/ { next }

    # Rule 2: Print the current line. This prints everything not skipped by Rule 1,
    # including 'comment:', 'protocol:', and all lines outside our block.
    { print }

    # Rule 3: If we just printed our block header, now is the time to inject
    # all the new, updated lines immediately after it.
    in_block && $0 == entry_name {
        print kernel_path_new
        if (enable_microcode == "yes" && microcode_path_new != "    module_path: boot():") {
            print microcode_path_new
        }
        print booster_path_new
        if (cmdline_new != "    kernel_cmdline: ") {
            print cmdline_new
        }
    }
    ' "${LIMINE_CONFIG_PATH}"

    log_info "${LIMINE_CONFIG_PATH} successfully updated."
}


# --- Main Execution ---
main() {
    if (( EUID != 0 )); then
        log_error "This script must be run with root privileges."
    fi
    parse_config

    local kernel_version
    kernel_version=$(get_kernel_version "${TARGET_KERNEL_PACKAGE}")
    log_info "Updating for kernel package ${TARGET_KERNEL_PACKAGE}, version ${kernel_version}"

    local machine_id
    machine_id=$(get_machine_id)
    log_info "Using machine-id: ${machine_id}"

    local dest_dir_rel="/${machine_id}/${TARGET_KERNEL_PACKAGE}"
    local dest_dir_abs="/boot${dest_dir_rel}"
    mkdir -p "${dest_dir_abs}"

    local kernel_image_path="${dest_dir_rel}/vmlinuz-${TARGET_KERNEL_PACKAGE}"
    local booster_image_path="${dest_dir_rel}/booster-${TARGET_KERNEL_PACKAGE}.img"
    local microcode_image_path=""
    if [[ "${ENABLE_MICROCODE:-no}" == "yes" ]]; then
        microcode_image_path=$(get_microcode_path)
        if [[ -n "${microcode_image_path}" ]]; then
             log_info "Found microcode: ${microcode_image_path}"
        fi
    fi

    build_booster_image "${kernel_version}" "${dest_dir_abs}/booster-${TARGET_KERNEL_PACKAGE}.img"

    update_limine_config \
        "${TARGET_ENTRY_NAME}" \
        "${kernel_image_path}" \
        "${microcode_image_path}" \
        "${booster_image_path}" \
        "${KERNEL_CMDLINE:-}"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
